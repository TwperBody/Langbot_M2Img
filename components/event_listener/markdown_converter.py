# Auto generated by LangBot Plugin SDK.
# Please refer to https://docs.langbot.app/en/plugin/dev/tutor.html for more details.
from __future__ import annotations

import re
import hashlib
import time
from typing import Optional

from langbot_plugin.api.definition.components.common.event_listener import EventListener
from langbot_plugin.api.entities import events, context
from langbot_plugin.api.entities.builtin.platform import message as platform_message

from ...config import DEFAULT_CONFIG, PLUGIN_CONFIG
from ...utils.markdown_converter import MarkdownConverter


class MarkdownConverterListener(EventListener):
    """监听消息并自动转换Markdown为图片"""

    def __init__(self):
        super().__init__()
        self.converter = MarkdownConverter()
        self.cache = {}  # 简单缓存
        
        @self.handler(events.PersonMessageReceived)
        async def handle_person_message(event_context: context.EventContext):
            await self._handle_message(event_context)
            
        @self.handler(events.GroupMessageReceived)
        async def handle_group_message(event_context: context.EventContext):
            await self._handle_message(event_context)

    async def _handle_message(self, event_context: context.EventContext):
        """处理消息"""
        try:
            # 检查是否启用自动转换
            if not PLUGIN_CONFIG.get('auto_convert', True):
                return
            
            # 获取消息文本
            message_text = self._extract_text(event_context.event.message_chain)
            if not message_text:
                return
            
            # 检查文本长度
            min_length = PLUGIN_CONFIG.get('min_text_length', 10)
            max_length = PLUGIN_CONFIG.get('max_text_length', 10000)
            
            if len(message_text) < min_length or len(message_text) > max_length:
                return
            
            # 检查是否包含Markdown标记
            if not self._is_markdown_text(message_text):
                return
            
            # 生成缓存键
            cache_key = self._generate_cache_key(message_text)
            
            # 检查缓存
            if PLUGIN_CONFIG.get('cache_enabled', True) and cache_key in self.cache:
                cache_entry = self.cache[cache_key]
                cache_ttl = PLUGIN_CONFIG.get('cache_ttl', 3600)
                if time.time() - cache_entry['timestamp'] < cache_ttl:
                    img_base64 = cache_entry['data']
                else:
                    # 缓存过期，删除
                    del self.cache[cache_key]
                    img_base64 = await self.converter.convert_to_image(message_text)
            else:
                # 转换为图片
                img_base64 = await self.converter.convert_to_image(message_text)
            
            if img_base64:
                # 保存到缓存
                if PLUGIN_CONFIG.get('cache_enabled', True):
                    self.cache[cache_key] = {
                        'data': img_base64,
                        'timestamp': time.time()
                    }
                
                # 发送图片
                await event_context.reply(
                    platform_message.MessageChain([
                        platform_message.Image(base64=img_base64)
                    ])
                )
        
        except Exception as e:
            # 错误处理
            if PLUGIN_CONFIG.get('log_level', 'INFO') == 'DEBUG':
                await event_context.reply(
                    platform_message.MessageChain([
                        platform_message.Plain(text=f"转换失败: {str(e)}")
                    ])
                )

    def _extract_text(self, message_chain) -> Optional[str]:
        """从消息链中提取文本"""
        text_parts = []
        for message in message_chain:
            if isinstance(message, platform_message.Plain):
                text_parts.append(message.text)
        return '\n'.join(text_parts) if text_parts else None

    def _is_markdown_text(self, text: str) -> bool:
        """检查文本是否包含Markdown标记"""
        markdown_patterns = [
            r'^#{1,6}\s+',  # 标题
            r'\*\*.*?\*\*',  # 粗体
            r'\*.*?\*',  # 斜体
            r'`.*?`',  # 行内代码
            r'```[\s\S]*?```',  # 代码块
            r'\[.*?\]\(.*?\)',  # 链接
            r'^\s*[-*+]\s+',  # 无序列表
            r'^\s*\d+\.\s+',  # 有序列表
            r'\|.*?\|',  # 表格
            r'\$.*?\$',  # 数学公式
        ]
        
        for pattern in markdown_patterns:
            if re.search(pattern, text, re.MULTILINE):
                return True
        return False

    def _generate_cache_key(self, text: str) -> str:
        """生成缓存键"""
        content = text + str(PLUGIN_CONFIG)  # 包含配置以确保配置变化时缓存失效
        return hashlib.md5(content.encode()).hexdigest() 